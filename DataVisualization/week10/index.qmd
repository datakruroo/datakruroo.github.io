---
title: "Geospatial Visualization"
author: "Siwachoat Srisuttiyakorn"
date: "2024-11-01"
categories: [data visualization, geospatial, ggplot2, sf, leaflet]
message: false
warning: false
toc: true
number-sections: true
bibliography: reference.bib
---


บทเรียนนี้จะกล่าวถึงการสร้างทัศนภาพข้อมูลเชิงภูมิศาสตร์ (geospatial data visualization) วัตถุประสงค์หลักของบทเรียนนี้ได้แก่

- เข้าใจและสามารถใช้ `{sf}` สำหรับจัดการและวิเคราะห์ข้อมูลเชิงภูมิศาสตร์

- สร้าง geospatial data visualization ผ่าน `{ggplot2}`

- สร้าง interactive mapping ด้วย `{leaflet}`

## Geospatial Data Visualization with `{sf}`

```{r}
## install.packages("sf")
library(sf)
library(tidyverse)
```


ของ R เป็น library ที่มีเครื่องมือสำหรับจัดการข้อมูลเชิงภูมิศาสตร์ โดยมีความสามารถในการจัดการข้อมูลเชิงภูมิศาสตร์ที่มีความซับซ้อน และมีการเก็บข้อมูลเชิงภูมิศาสตร์ในรูปแบบของ simple features [@Pebesma_sf_2024] ซึ่งเป็นมาตรฐานของข้อมูลเชิงภูมิศาสตร์ที่ถูกกำหนดโดย ISO 19125-1:2004

มาตรฐานดังกล่าวกำหนดวิธีการแทนค่าและจัดเก็บข้อมูลวัตถุในโลกจริงที่มีลักษณะเชิงพื้นที่ (spatial geometry) เช่น จุด เส้น และพื้นที่ในระบบข้อมูลที่เกี่ยวกับภูมิสารสนเทศ (GIS) simple features จะประกอบด้วยสองส่วนหลัก คือ

- ส่วนข้อมูลเชิงภูมิศาสตร์ (geometry) ที่เก็บข้อมูลเชิงพื้นที่ของวัตถุในโลกจริง เช่น จุด เส้น และพื้นที่

- ส่วนข้อมูลที่เกี่ยวข้อง (attribute) ที่เก็บข้อมูลที่เกี่ยวข้องกับวัตถุในโลกจริง เช่น ชื่อ รหัส และค่าที่เกี่ยวข้อง


นอกจากนี้ `{sf}` ยังรองรับการอ่านและเขียนไฟล์ Shapefile ซึ่งเป็นรูปแบบไฟล์ที่พัฒนาโดย ESRI สำหรับจัดเก็บข้อมูลเชิงเวกเตอร์ เช่น ข้อมูลเกี่ยวกับพิกัดและข้อมูลบรรยายที่ใช้ในระบบข้อมูลภูมิสารสนเทศ (GIS) รูปแบบ Shapefile ประกอบด้วยหลายไฟล์ เช่น `.shp` (เก็บข้อมูลเรขาคณิต), `.shx` (ดัชนีเชิงพื้นที่), และ `.dbf` (เก็บข้อมูลเชิงบรรยาย) ซึ่ง `{sf}` สามารถอ่านและแปลงเป็น sf-object เพื่อให้ใช้งานและวิเคราะห์ใน R ได้ง่ายขึ้น

สำหรับการสร้าง Geospatial Visualization ของประเทศไทย สิ่งสำคัญที่ต้องเริ่มต้นคือการมี ไฟล์ข้อมูลภูมิสารสนเทศ ที่ใช้เป็นพื้นฐานในการสร้างแผนที่ ซึ่งไฟล์นี้จะบรรจุข้อมูลเรขาคณิตเชิงพื้นที่ของพื้นที่ต่าง ๆ ในประเทศไทย เช่น พิกัดของขอบเขตจังหวัดหรืออำเภอ โดยข้อมูลในไฟล์นี้จะเป็นพื้นฐานที่แสดงรูปร่างของแต่ละพื้นที่

หลังจากมีไฟล์พื้นฐานแล้ว เราสามารถ รวบรวมข้อมูลเชิงบรรยาย (attributes) เพิ่มเติม เช่น ข้อมูลประชากร รายได้เฉลี่ย หรือความเสี่ยงต่อภัยธรรมชาติ แล้วใช้แพ็กเกจ {sf} ใน R เพื่อรวมข้อมูลเชิงบรรยายเหล่านี้เข้ากับข้อมูลพื้นที่ (spatial data) โดยการ join ตามขอบเขตพื้นที่ เช่น จังหวัดหรืออำเภอ ทำให้เราสามารถแสดงผลข้อมูลเชิงบรรยายร่วมกับแผนที่เชิงภูมิศาสตร์ได้

### แหล่งข้อมูลภูมิสารสนเทศของประเทศไทย

- [OCHA Services](https://data.humdata.org/dataset/cod-ab-tha)

- [GADM](https://gadm.org/download_country_v3.html)

- [สำนักงานทรัพยากรน้ำแห่งชาติ](https://opendata.onwr.go.th/dataset)

### นำเข้า shapefile

เราสามารถนำเข้าไฟล์ข้อมูลภูมิสารสนเทศ (shapefile) ด้วยคำสั่ง `st_read()` ของ `{sf}` โดยระบุที่อยู่ของไฟล์ shapefile ที่ต้องการนำเข้า ดังตัวอย่างต่อไปนี้

```{r}
thai_prov_map <- st_read("/Users/choat/Downloads/tha_adm_rtsd_itos_20210121_shp/tha_admbnda_adm1_rtsd_20220121.shp")
```
ทดลองเรียกตัวอย่างข้อมูลขึ้นมาดู

```{r}
head(thai_prov_map)
```

สังเกตว่าชุดข้อมูล `sf` มีส่วนประกอบสองส่วนดังที่กล่าวไว้ ส่วนแรกที่เป็นข้อมูลเชิงพื้นที่จะอยู่ในคอลัมน์ `geometry` ซึ่งเก็บข้อมูลเรขาคณิตเชิงพื้นที่ของพื้นที่ต่าง ๆ ในประเทศไทย ส่วนที่สองคือข้อมูลเชิงบรรยายที่เกี่ยวข้องกับพื้นที่นั้น ๆ จะอยู่ในคอลัมน์อื่น ๆ ที่ไม่ใช่ `geometry` ซึ่งเก็บข้อมูลที่เกี่ยวข้องกับพื้นที่นั้น ๆ เช่น ชื่อ รหัส และค่าที่เกี่ยวข้อง

ชุดข้อมูลข้างต้นเมื่อพิจารณาส่วน `geometry` จะเห็นว่ามีการกำกับไว้ว่าเป็น `MULTIPOLYGON` ซึ่งเป็นรูปแบบของเรขาคณิตเชิงพื้นที่ประเภทหนึ่งที่มีพื้นที่ย่อยหลาย ๆ พื้นที่ีรวมกัน เราสามารถนำข้อมูลส่วนนี้มาสร้างทัศนภาพข้อมูลได้เลยดังนี้

```{r}
### plot(thai_prov_map)
plot(thai_prov_map["Shape_Area"])
```


### `{ggplot2}` with `{sf}`

เราสามารถใช้ ggplot2 กับ object ประเภท `{sf}` ได้โดยใช้ `geom_sf()` ซึ่งเป็น geom ที่ใช้สำหรับพล็อตข้อมูลเชิงภูมิศาสตร์ ดังตัวอย่างต่อไปนี้

```{r}
p1 <- thai_prov_map %>% 
  ggplot() + 
  geom_sf(aes(geometry = geometry, fill = Shape_Area))
p1
```


### Coordinate Reference System

Coordinate Reference System (CRS) เป็นระบบพิกัดที่ใช้ในการกำหนดตำแหน่งของวัตถุในโลกจริงแบบ 3D ให้อยู่บนแผนที่ ระบบ CRS มีหลายรูปแบบขึ้นอยู่กับการใช้งาน เช่น

- WGS84 (World Geodetic System 1984: EPSG:4326) เป็นระบบพิกัดที่ใช้กันทั่วไปน่าจะแพร่หลายที่สุดในโลกระบบหนึ่งอยู่ในกลุ่ม geographic coordinate system (GCS) ลักษณะเด่นคือการระบุตำแหน่งต่าง ๆ หรือรูปทรงเรขาคณิตบนโลกผ่านพิกัดลองจิจูด (latitude) และละติจูด (longitude) เป็นระบบที่ง่ายแต่อาจไม่ได้มีความแม่นยำสูงมาก

- NAD83 (EPSG:4269) คล้าย WGS84 แต่มีการปรับปรุงความแม่นยำในการฉายภาพให้ตรงกับสภาพของทวีปอเมริกาเหนือมากขึ้น


- Web Mercator (EPSG:3857) เป็นระบบพิกัดประเภท projected coordinate system (PCS) เน้นใช้แสดงผลบน website เช่น google map, openstreetmap  ลักษณะเด่นคือมีการแปลงพิกัดบนทรงกลม (โลก) ให้เป็นพื้นราบ 2D โดยใช้ mercator projection วิธีการนี้มีแนวโน้มบิดเบือนพื้นที่บริเวณขั้วโลกให้ดูใหญ่กว่าความเป็นจริง

- UTM (Universal Transverse Mercator) เป็นระบบพิกัดที่ใช้ในการแสดงผลบนแผนที่ที่มีความแม่นยำสูง โดยแบ่งโลกออกเป็น 60 โซนตามแนวตั้ง แต่ละโซนมีความกว้าง 6 องศา และมีระบบพิกัดของตัวเอง การแปลงพิกัดบนทรงกลม (โลก) ให้เป็นพื้นราบ 2D โดยใช้ Transverse Mercator projection พิกัดนี้เหมาะกับการทำแผนที่พื้นที่ขนาดเล็ก

ใน R เราสามารถตรวจสอบ CRS ของข้อมูลเชิงภูมิศาสตร์ได้ด้วยคำสั่ง `st_crs()` และเปลี่ยน CRS ด้วยคำสั่ง `st_transform()` ดังตัวอย่างต่อไปนี้

```{r}
st_crs(thai_prov_map)
```

```{r fig.width = 15, fig.height=6}
library(patchwork)
p2 <- thai_prov_map %>% 
  st_transform(crs = 3857) %>%
  ggplot()+
  geom_sf(aes(geometry = geometry, fill = Shape_Area))+
  ggtitle("EPSG:3857")

p3 <- thai_prov_map %>% 
  st_transform(crs = 32647 ) %>% 
  ggplot()+
  geom_sf(aes(geometry = geometry, fill = Shape_Area))+
  ggtitle("EPSG:32647")

p1+p2+p3
```

### Geometry

ข้อมูลเชิงพื้นที่ที่อยู่ในรูปของ geometry ใน sf มีหลายประเภท ซึ่งแต่ละประเภทจะเก็บข้อมูลเรขาคณิตเชิงพื้นที่ของวัตถุในโลกจริงในรูปแบบที่แตกต่างกัน ประเภทข้อมูลหลัก ๆ เช่น

- POINT เป็นข้อมูลเรขาคณิตเชิงพื้นที่ของจุดบนแผนที่ ซึ่งมีค่าพิกัดลองและละติจูด

- LINESTRING เป็นข้อมูลเรขาคณิตเชิงพื้นที่ของเส้นที่เชื่อมต่อจุดหลาย ๆ จุดเข้าด้วยกัน

- POLYGON เป็นข้อมูลเรขาคณิตเชิงพื้นที่ของพื้นที่ที่มีขอบเขตเป็นเส้นต่อเนื่อง ๆ ที่ปิดรูป

- MULTIPOLYGON เป็นข้อมูลเรขาคณิตเชิงพื้นที่ของพื้นที่ที่มีขอบเขตเป็นเส้นต่อเนื่อง ๆ ที่ปิดรูป แต่มีพื้นที่ย่อยหลาย ๆ พื้นที่รวมกัน

ในแผนภาพหนึ่ง ๆ อาจจะต้องใช้ geometry หลายประเภทเพื่อนำเสนอข้อมูลเชิงพื้นที่หลากหลายลักษณะขึ้นอยู่งาน

### Attributes

Attribute เป็นข้อมูลคุณลักษณะของวัตถุเชิงพื้นที่ใช้บรรยายสภาพหรือบริบทของวัตถุนั้น ๆ ในโลกจริง ใน `{sf}` จะเก็บ attribute ดังกล่าวในรูปแบบตารางเหมือนกับ data.frame แต่จะมีความเชื่อมโยงกับข้อมูลเชิงพื้นที่ในคอลัมน์ `geometry` พิจารณาชุดข้อมูล `thai_prov_map` ที่เราได้นำเข้ามาก่อนหน้านี้ จะเห็นว่ามีตัวแปรคุณลักษณะหลายตัวที่นำเข้ามาพร้อมกัน

```{r}
glimpse(thai_prov_map)
```

ผลลัพธ์ข้างต้นจะเห็นว่า

- ชุดข้อมูลมี 77 แถว (ตามจำนวนจังหวัด) และมี 17 คอลัมน์

- คอลัมน์ `geometry` เก็บข้อมูลเรขาคณิตเชิงพื้นที่ของพื้นที่ต่าง ๆ ในประเทศไทย

- คอลัมน์ที่เหลือเป็นข้อมูลพื้นฐานที่เกี่ยวข้องของแต่ละจังหวัด เช่น ความยาว ขนาดพื้นที่ ชื่อ รหัส ...


### `{sf}` with `{tidyverse}` 

เนื่องจาก `{sf}` ถูกออกแบบให้มีลักษณะเป็นชุดข้อมูลแบบ data.frame ดังนั้นจึงสามารถทำงานภายใต้ tidyverse ได้โดยตรง ซึ่งเป็นข้อได้เปรียบที่สำคัญที่ทำให้สามารถใช้ `{sf}` ในการจัดการข้อมูลเชิงภูมิศาสตร์ได้ง่ายขึ้น เบื้องต้นเราสามารถใช้ `{dplyr}` หรือ `{tidyr}` รวมทั้ง `{ggplot2}` (แสดงให้ดูไปแล้ว) เพื่อจัดกระทำและสร้างทัศนภาพข้อมูลเชิงพื้นที่ตามที่ต้องการได้ เช่น

#### การคัดเลือกตัวแปร

```{r}
thai_prov_map %>% 
  select(ADM1_TH, Shape_Area) %>% 
  head()
```

ผลลัพธ์ข้างต้นเราจะเห็นว่า `geometry` จะติดมากับ attribute ที่เราเลือกไว้ด้วยเสมอ

#### การคัดกรองข้อมูล

```{r fig.width = 10, figh.height = 6}
p4 <- thai_prov_map %>% 
  filter(ADM1_TH == "กรุงเทพมหานคร") %>% 
  ggplot()+
  geom_sf(fill = "steelblue")+
  theme_void()+
  ggtitle("Bangkok")

p4
```


#### การ join ข้อมูล

โดยปกติเราสามารถเข้าถึงข้อมูลเชิงพื้นที่ที่จะใช้สำหรับสร้างแผนที่ที่ต้องการได้ไม่ยาก ปัญหาหลักคือเราต้องการชุดข้อมูลเชิงพื้นที่ที่ประกอบด้วย attribute เป้าหมายที่จะใช้นำเสนอซึ่งชุดข้อมูลลักษณะนี้ผู้วิเคราะห์จำเป็นต้องสร้างเอง ยกตัวอย่างเช่น

- [ค่าใช้จ่ายเฉลี่ยต่อเดือนของครัวเรือนรายจังหวัด](average_expense.xlsx)


```{r}
library(readxl)
data_expense <- read_excel("average_expense.xlsx", sheet = 1, skip = 2)
head(data_expense, 10)

```

สมมุติว่าวัตถุประสงค์คือการ plot รายจ่ายโดยเฉลี่ยของครัวเรือนในแต่ะละจังหวัด เราจำเป็นที่จะต้องเชื่อมโยงข้อมูลรายจ่ายดังกล่าวเข้ากับข้อมูลเชิงพื้นที่ใน `thai_prov_map` อย่างไรก็ตามหากใช้การรวมข้อมูลด้วย `dplyr` แบบปกติจะทำให้สูญเสีย class ของข้อมูลเดิมคือ `sf` ไป การแก้ปัญหาดังกล่าวสามารถทำได้โดยใช้ `st_as_sf()` ในการแปลงข้อมูลเชิงพื้นที่ที่เราได้รวมข้อมูลเชิงบรรยายเข้าไปกลับเป็น `sf` อีกครั้ง 


```{r}
data_expense %>% 
  rename(region = 1,
         prov = 2,
         year2566 = `2566`) %>% 
  select(region, prov, year2566) %>% 
  fill(region, .direction = "down") %>% 
  right_join(thai_prov_map, 
             by = join_by("prov" == "ADM1_TH")) %>% 
  st_as_sf() %>% 
  ggplot()+
  geom_sf(aes(fill = year2566))+
  scale_fill_gradient2(low = "maroon", 
                       mid = "white",
                       high = "steelblue", 
                       midpoint = 20000)+
  theme_light()
```

#### `group_by()` และ `summarise()`

ทำนองเดียวกับการจัดกระทำข้อมูลทั่วไป เราสามารถใช้ `group_by()` และ `summarise()` ในการสรุปข้อมูลเชิงพื้นที่ได้เช่นกัน

```{r}
expense_st_joined <- data_expense %>% 
  rename(region = 1,
         prov = 2,
         year2566 = `2566`) %>% 
  select(region, prov, year2566) %>% 
  fill(region, .direction = "down") %>% 
  right_join(thai_prov_map, 
             by = join_by("prov" == "ADM1_TH")) %>% 
  st_as_sf()
```



```{r}
expense_st_joined %>% 
  group_by(region) %>% 
  summarise(avg_expense = mean(year2566)) %>% 
  ggplot()+
  geom_sf(aes(fill = avg_expense))+
  scale_fill_gradient2(low = "maroon", 
                       mid = "white",
                       high = "steelblue", 
                       midpoint = 20000)+
  theme_bw()+
  ggtitle("Average Expense by Region")
```

จะเห็นว่าการใช้ grammar of data maniputation ร่วมกับ `{sf}` ทำให้เราสามารถจัดการข้อมูลเชิงพื้นที่ได้อย่างมีประสิทธิภาพ สามารถนำเสนอมิติต่าง ๆ ของข้อมูลได้โดยง่าย


### Geometry Operations

- `st_distance()` ใช้คำนวณระยะห่างระหว่าง geometry สองตัว

- `st_union()` ใช้รวม geometry หลายตัวเข้าด้วยกัน

- `st_centroid()` ใช้หาจุดศูนย์กลางของ geometry

st_intersects(), st_disjoint(), st_touches(), st_crosses(), st_within(), st_contains(), st_overlaps(), st_equals(), st_covers(), st_covered_by(), st_equals_exact() and st_is_within_distance() รายละเอียดถ้าจำเป็นต้องใช้สามารถศึกษาได้จาก [@Pebesma_sf_2024]


```{r}
x <- thai_prov_map %>% filter(ADM1_TH %in% c("กรุงเทพมหานคร","ยะลา","เชียงใหม่"))
y <- thai_prov_map %>% filter(ADM1_TH == "นครราชสีมา")
st_distance(x,y)
st_distance(x,y) %>% units::set_units(km)
```


### กิจกรรม 1

ขอให้ผู้เรียนลองสร้างทัศนภาพข้อมูลพื้นที่เสี่ยงภัยของประเทศดังรูป


```{r echo = F, message = F, warning = F}
risk <- st_read('/Users/choat/Downloads/5.พื้นที่เป้าหมาย (Area Based)/All_Thai_AB_161061.shp', options = "ENCODING=WINDOWS-874")

thai_prov_map %>% 
  ggplot()+
  geom_sf()+
  geom_sf(data = risk %>% 
                 filter(str_detect(TYPE1, "เสี่ยง")) %>% 
                 st_transform(crs = 4326),
          aes(fill = TYPE1))+
  labs(fill = "ความเสี่ยง")+
  theme_bw()+
  theme(text = element_text(family = "ChulaCharasNew"))
```

ชุดข้อมูลที่เกี่ยวข้อง

- [พื้นที่เป้าหมาย](https://opendata.onwr.go.th/dataset/onwr_66_03_01)

- [OCHA Services](https://data.humdata.org/dataset/cod-ab-tha)



## Geospatial Maps with `{leaflet}`

`{leaflet}` เป็น library ที่ถูกออกแบบมาเพื่อสร้างทัศนภาพข้อมูลเชิงพื้นที่แบบ interactive บน website โดยใช้ภาษา JavaScript และ HTML ในการสร้างแผนที่ ใน R เราสามารถใช้ `{leaflet}` ร่วมกับ `{sf}`
ในบริบทของ Data Science การใช้ leaflet มีประโยชน์มากโดยเฉพาะด้านการนำเสนอหรือสื่อสารข้อมูล

- นำเสนอผลการวิเคราะห์/สารสนเทศที่อิงกับตำแหน่งเชิงภูมิศาสตร์

- ทำความเข้าใจ attribute ร่วมกับบริบทเชิงพื้นที่ ซึ่งอาจช่วยให้ผู้ใช้ทำความเข้าใจความสัมพันธ์ระหว่างคุณลักษณะของหน่วยข้อมูลกับพื้นที่เชิงภูมิศาสตร์

- การสร้างแผนที่ที่สามารถปรับเปลี่ยนได้ตามความต้องการ ช่วยให้ผู้ใช้สามารถสำรวจจข้อมูลด้วยตนเองได้ง่าย และลดความซับซ้อนในการสื่อสารข้อมูล


โครงสร้างของแผนภาพแบบ leaflet ประกอบด้วย layer ของทัศนภาพหลายชั้นซ้อนกันในทำนองเดียวกับ `{ggplot2}` 


- layer แรกกำหนดด้วยฟังก์ชัน `leaflet()` ซึ่งเป็น layer หลักของแผนที่ ทำนองเดียวกับ `ggplot()`

- `addTiles()` เป็น layer ที่ใช้เพิ่มแผนที่พื้นฐาน ซึ่งสามารถเลือกใช้แผนที่จาก OpenStreetMap, Stamen, Esri หรือ Mapbox ได้

- การเชื่อมต่อกันระหว่าง layer จะใช้ piping operator `%>%` 

พิจารณาผลลัพธ์ที่ได้จาก syntax ด้านล่าง

```{r}
## install.packages("leaflet")
library(leaflet)
leaflet() %>% 
  addTiles()
```

### Map Providers

leaflet สามารถเลือกใช้แผนที่พื้นฐานจากหลายแหล่ง ซึ่งสามารถกำหนดได้ด้วย ้ฟังก์ชัน `addProviderTiles()` โดยระบุชื่อของแหล่งที่ต้องการใช้ ตัวอย่างเช่น

```{r}
leaflet() %>% 
  addProviderTiles(provider = "OpenStreetMap")

leaflet() %>%
  addProviderTiles(providers$OpenRailwayMap)

leaflet() %>% 
  addProviderTiles(providers$Esri.WorldImagery)
```

รายการแผนที่พื้นฐานที่สามารถเลือกใช้ได้อาจเลือกดูจาก [https://leaflet-extras.github.io/leaflet-providers/preview/](https://leaflet-extras.github.io/leaflet-providers/preview/) หรือใช้คำสั่ง




```{r}
leaflet::providers %>% head()
```

### Adding Polygons in leaflet

เราสามารถเติม geometry ของข้อมูลเชิงพื้นที่ใน leaflet ได้โดยใช้ `addPolygons()` ฟังก์ชันนี้จะต้องทำงานร่วมกับ `{sf}`

```{r}
mymap <- leaflet() %>% 
  addTiles() %>% 
  addPolygons(data = thai_prov_map,
              col = "steelblue",
              label = ~ADM1_TH)
mymap
```


### Setting View

เราสามารถกำหนดขอบเขตของแผนที่ได้ โดยใช้ฟังก์ชัน `setView()` ซึ่งระบุพิกัดลองและละติจูดของจุดศูนย์กลางของแผนที่ และระดับการซูมของแผนที่ ดังตัวอย่างต่อไปนี้

```{r}

mymap %>% 
  setView(lng = 100, lat = 15, zoom = 4)

```


นอกจากการกำหนดตำแหน่ง เรายังสามารถจำกัดขอบเขตของแผนที่เพื่อควบคุมการซูมเข้าออกได้ด้วยการระบุพิกัดของจุดสองจุดในซ้ายล่างและขวาบนของแผนที่ โดยใช้ `setMaxBounds()` ดังนี้



เราสามารถจัดกระทำส่วนชุดข้อมูลของ `{sf}` ก่อนการนำเสนอใน leaflet ได้เช่น ต้องการนำเสนอเฉพาะในจังหวัดเชียงใหม่

```{r}
cmx <- thai_prov_map %>% 
  filter(ADM1_TH == "เชียงใหม่")
centroid <- st_centroid(st_union(cmx))
centroid_coords <- st_coordinates(centroid)

cmx_map <- leaflet() %>% 
  # ซูมไปยังพื้นที่เชียงใหม่
  setView(lng = centroid_coords[1], lat = centroid_coords[2], zoom = 7) %>% 
  setMaxBounds(centroid_coords[1]-0.01, centroid_coords[2]-0.01, 
               centroid_coords[1]+0.01, centroid_coords[2]+0.01) %>% 
  addTiles() %>% 
  addPolygons(data = thai_prov_map %>%
                filter(ADM1_TH == "เชียงใหม่"),
              col = "steelblue",
              label = ~ADM1_TH) %>%
  # เพิ่มพื้นหลังเฉพาะขอบเขตเชียงใหม่
  addPolygons(
    data = thai_prov_map %>%
                filter(ADM1_TH == "เชียงใหม่"),
    fillColor = "lightgray",
    color = "blue",
    weight = 2,
    opacity = 1,
    fillOpacity = 0.2,
    label = "จังหวัดเชียงใหม่"
  ) %>% 
  leafletOptions(zoomControl = FALSE)

cmx_map 
```



### Adding Markers

เราสามารถเพิ่ม marker บนแผนที่ได้โดยใช้ `addMarkers()`, `addCircle()`, `addCircleMarkers()` หรือ `addPopups()`


```{r}
library(leaflet)

## สร้างชุดข้อมูลฝั่ง attribute

example_data <- read_csv("example_data.csv")
aggregate_data <- example_data %>% 
  filter(student_level == "p6") %>% 
  group_by(province, school_lon, school_lat, school_size, hard_to_reach, school_code3) %>% 
  summarise(avg_risk = mean(risk_index_df5)) %>% 
  filter(province == "เชียงใหม่")

# สร้างพาเลตสีสำหรับค่า avg_risk
risk_palette <- colorBin(palette = "plasma", domain = aggregate_data$avg_risk, bins = c(0,0.6,0.8,1.0))

# ตั้งค่า zoom ที่ต้องการ (ตัวอย่างใช้ระดับ zoom = 10)
zoom_level <- 7

leaflet() %>% 
  # ตั้งค่า zoom คงที่และระบุตำแหน่งที่ต้องการ
  setView(lng = centroid_coords[1], lat = centroid_coords[2], zoom = zoom_level) %>%
  
  # เพิ่มแผนที่พื้นหลังและปิดการซูมด้วย scroll wheel
  addTiles(options = tileOptions(zoomControl = FALSE)) %>%
    addPolygons(data = thai_prov_map %>%
                filter(ADM1_TH == "เชียงใหม่"),
              col = "steelblue") %>%
  # เพิ่ม Circle Markers
  addCircleMarkers(
    data = aggregate_data,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),  
    fillOpacity = 0.8,
    radius = 3,
    stroke = TRUE,
    opacity = 1,
    popup = ~paste("<b>ระดับชั้นประถมศึกษาปีที่ 6</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2))
  ) %>%
  addLegend(
    "bottomright",
    pal = risk_palette,
    values = aggregate_data$avg_risk,
    title = "Risk Score",
    opacity = 1,
    labFormat = function(type, cuts, p) {
      labels <- c("Low", "Moderate", "High")  # กำหนด labels ที่ต้องการ
    }
  ) %>% 
  addMiniMap(tiles = "OpenStreetMap.Mapnik",
             zoomAnimation = T)
```



### clusterOptions


เราสามารถกำหนดอาร์กิวเมนท์ `clusterOptions = markerClusterOptions()` เพื่อให้ leaflet จัดกลุ่ม marker ที่อยู่ในพื้นที่ใกล้เคียงเข้าด้วยกัน ทำให้การสำรวจทำความเข้าใจแผนที่ได้สะดวกขึ้น


```{r}

leaflet() %>% 
  # ตั้งค่า zoom คงที่และระบุตำแหน่งที่ต้องการ
  setView(lng = centroid_coords[1], lat = centroid_coords[2], zoom = zoom_level) %>%
  
  # เพิ่มแผนที่พื้นหลังและปิดการซูมด้วย scroll wheel
  addTiles(options = tileOptions(zoomControl = FALSE)) %>%
    addPolygons(data = thai_prov_map %>%
                filter(ADM1_TH == "เชียงใหม่"),
              col = "steelblue") %>%
  # เพิ่ม Circle Markers
  addCircleMarkers(
    data = aggregate_data,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),  
    fillOpacity = 0.8,
    radius = 3,
    stroke = TRUE,
    opacity = 1,
    clusterOptions = markerClusterOptions(),
    popup = ~paste("<b>ระดับชั้นประถมศึกษาปีที่ 6</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2))
  ) %>%
  addLegend(
    "bottomright",
    pal = risk_palette,
    values = aggregate_data$avg_risk,
    title = "Risk Score",
    opacity = 1,
    labFormat = function(type, cuts, p) {
      labels <- c("Low", "Moderate", "High")  # กำหนด labels ที่ต้องการ
    }
  ) %>% 
  addMiniMap(tiles = "OpenStreetMap.Mapnik",
             zoomAnimation = T)
  
```

### Adding LayersControl

หลายครั้งเราอาจมีข้อมูลหลายมิติที่จะต้องแสดงบนแผนที่ การนำเสนอทุกมิติพร้อมกันอาจทำให้เกิดความสับสนหรือทำความเข้าใจสารสนเทศได้ยาก ในกรณีนี้เราสามารถใช้ `addLayersControl()` เพื่อเพิ่มปุ่มควบคุมเพื่อเปิด-ปิด layer ต่าง ๆ ได้



```{r}
library(leaflet)
library(akima)
library(sf)
library(terra)
library(dplyr)

# 1. สร้าง grid จากข้อมูล school_lon, school_lat, avg_risk
interpolated <- with(aggregate_data, 
                     interp(x = school_lon, y = school_lat, z = avg_risk, 
                            xo = seq(min(school_lon), max(school_lon), length = 100),
                            yo = seq(min(school_lat), max(school_lat), length = 100),
                            duplicate = "mean"
))
```


syntax ข้างต้นทำหน้าที่ สร้างข้อมูล grid ของตำแหน่งโรงเรียน (school_lon, school_lat) และค่าตัวแปร (avg_risk) โดยใช้ฟังก์ชัน interp() จากแพ็กเกจ akima (interpolate เป็นการสร้างข้อมูลใหม่จากข้อมูลที่มีอยู่โดยใช้ข้อมูลที่มีอยู่เป็นตัวแปรอ้างอิง ในลักษณะการเชื่อมต่อจุดข้อมูล)

ผลลัพธ์จากการสร้าง grid ข้างต้นทำให้นำไปใช้ในการสร้าง contour หรือ heatmap บนแผนที่ได้ใน leaflet จาก syntax จะเห็นว่ามีการสร้าง grid ขนาด 100x100 และมีขอบเขตอยู่ภายใต้ข้อมูล lattitude และ longtitude ของโรงเรียนทั้งหมดใน `aggregate_data`

- `interp()` ทำหน้าที่ประมาณ coordinate บนพื้นผิวแบบ 2D โดยใช้ข้อมูลที่กำหนด

- `x = school_lon, y = school_lat` กำหนดข้อมูล latitude และ longitude ของโรงเรียนที่ใช้เป็นต้นแบบในการประมาณ grid

- `z = avg_risk` กำหนดข้อมูลที่จะใช้ประมาณ surface ของ grid 


```{r}
# 2. แปลงเป็น raster สำหรับสร้าง contour
r <- rast(interpolated)

# 3. สร้าง contour lines จากข้อมูล raster
contours <- terra::as.contour(r, levels = seq(min(values(r), na.rm = TRUE), max(values(r), na.rm = TRUE), by = 0.1))

# 4. แปลง contour lines เป็น sf สำหรับการแสดงผลใน leaflet
contours_sf <- st_as_sf(contours)

# 5. สร้างแผนที่ leaflet และเพิ่ม contour lines
# สร้างเงื่อนไขเพื่อแบ่งกลุ่มตามระดับความเสี่ยง
low_risk <- aggregate_data %>% filter(avg_risk < 0.6)
moderate_risk <- aggregate_data %>% filter(avg_risk >= 0.6 & avg_risk < 0.8)
high_risk <- aggregate_data %>% filter(avg_risk >= 0.8)

leaflet() %>%
  # เพิ่มแผนที่พื้นหลัง
  addTiles(group = "Base Map") %>%
  
  # เพิ่ม Polygon ของจังหวัดเชียงใหม่
  addPolygons(
    data = thai_prov_map %>% filter(ADM1_TH == "เชียงใหม่"),
    color = "black",
    fillOpacity = 0.2,
    weight = 2,
    label = ~ADM1_TH,
    group = "Chiang Mai Boundary"
  ) %>%
  
  # เพิ่ม contour lines
  addPolylines(
    data = contours_sf,
    color = ~risk_palette(level),
    weight = 1.5,
    opacity = 0.8,
    label = ~paste("Risk Level:", round(level, 2)),
    group = "Contour Lines"
  ) %>%
  
  # เพิ่ม Circle Markers สำหรับแต่ละกลุ่มความเสี่ยง
  addCircleMarkers(
    data = low_risk,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),
    opacity = 0.5,
    radius = 3,
    stroke = TRUE,
    popup = ~paste("<b>ระดับความเสี่ยง: ต่ำ</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2)),
    group = "Low Risk School"
  ) %>%
  addCircleMarkers(
    data = moderate_risk,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),
    opacity = 0.5,
    radius = 3,
    stroke = TRUE,
    popup = ~paste("<b>ระดับความเสี่ยง: ปานกลาง</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2)),
    group = "Moderate Risk School"
  ) %>%
  addCircleMarkers(
    data = high_risk,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),
    opacity = 0.5,
    radius = 3,
    stroke = TRUE,
    popup = ~paste("<b>ระดับความเสี่ยง: สูง</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2)),
    group = "High Risk School"
  ) %>%
  
  # เพิ่มตัวควบคุม layers สำหรับ Base Map, Contour Lines, Boundary และความเสี่ยงต่าง ๆ
  addLayersControl(
    baseGroups = c("Base Map"),
    overlayGroups = c("Chiang Mai Boundary", "Contour Lines", "Low Risk School", "Moderate Risk School", "High Risk School"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  # เพิ่ม legend สำหรับระดับความเสี่ยง
  addLegend(
    position = "bottomright",
    pal = risk_palette,
    values = aggregate_data$avg_risk,
    title = "Risk Score",
    opacity = 1
  ) %>% 
  addLegend(
    "bottomright",
    pal = risk_palette,
    values = aggregate_data$avg_risk,
    title = "Risk Score",
    opacity = 1,
    labFormat = function(type, cuts, p) {
      labels <- c("Low", "Moderate", "High")  # กำหนด labels ที่ต้องการ
    }
  ) 
```



```{r}

risk_palette <- colorBin(palette = c("white","orange","maroon"), domain = aggregate_data$avg_risk, bins = c(0,0.6,0.8,1.0))


leaflet() %>%
  # เพิ่มแผนที่พื้นหลัง
  addProviderTiles(
    provider = "Stadia.AlidadeSmoothDark",  
    group = "Base Map") %>%
  
  # เพิ่ม Polygon ของจังหวัดเชียงใหม่
  addPolygons(
    data = thai_prov_map %>% filter(ADM1_TH == "เชียงใหม่"),
    color = "white",
    fillOpacity = 0.2,
    weight = 2,
    label = ~ADM1_TH,
    group = "Chiang Mai Boundary"
  ) %>%
  
  # เพิ่ม contour lines
  addPolylines(
    data = contours_sf,
    color = ~risk_palette(level),
    weight = 1.5,
    opacity = 0.8,
    label = ~paste("Risk Level:", round(level, 2)),
    group = "Contour Lines"
  ) %>%
  
  # เพิ่ม Circle Markers สำหรับแต่ละกลุ่มความเสี่ยง
  addCircleMarkers(
    data = low_risk,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),
    opacity = 0.5,
    radius = 3,
    stroke = TRUE,
    popup = ~paste("<b>ระดับความเสี่ยง: ต่ำ</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2)),
    group = "Low Risk School"
  ) %>%
  addCircleMarkers(
    data = moderate_risk,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),
    opacity = 0.5,
    radius = 3,
    stroke = TRUE,
    popup = ~paste("<b>ระดับความเสี่ยง: ปานกลาง</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2)),
    group = "Moderate Risk School"
  ) %>%
  addCircleMarkers(
    data = high_risk,
    lng = ~school_lon,
    lat = ~school_lat,
    color = ~risk_palette(avg_risk),
    opacity = 0.5,
    radius = 3,
    stroke = TRUE,
    popup = ~paste("<b>ระดับความเสี่ยง: สูง</b>", "<br>",
                   "<b>School =</b>", school_code3,
                   "<br>",
                   "<b>ขนาดโรงเรียน</b> =", school_size,
                   "<br>",
                   "<b>ความยุ่งยากในการเข้าถึง</b> =", hard_to_reach,
                   "<br>",
                   "<b>CMER Score</b> =", round(avg_risk, 2)),
    group = "High Risk School"
  ) %>%
  
  # เพิ่มตัวควบคุม layers สำหรับ Base Map, Contour Lines, Boundary และความเสี่ยงต่าง ๆ
  addLayersControl(
    baseGroups = c("Base Map"),
    overlayGroups = c("Chiang Mai Boundary", "Contour Lines", "Low Risk School", "Moderate Risk School", "High Risk School"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = risk_palette,
    values = aggregate_data$avg_risk,
    title = "Risk Score",
    opacity = 1,
    labFormat = function(type, cuts, p) {
      labels <- c("Low", "Moderate", "High")  # กำหนด labels ที่ต้องการ
    }
  ) 
```

### กิจกรรม 2

ลองใช้ข้อมูลใน `example_data.csv` เพื่อออกแบบทัศนภาพข้อมูลเชิงพื้นที่โดยใช้ leaflet เป็นเครื่องมือ ทั้งนี้้ขอให้พิจารณาประเด็นต่อไปนี้ในการออกแบบ


1. Key Message ของการนำเสนอคืออะไร

2. เราวางแผนนำเสนอ key message นี้ในแผนภาพอย่างไร

3. สร้างแผนที่ leaflet ตามแนวคิดข้างต้น




 