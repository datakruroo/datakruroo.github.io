library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 10, activation = 'linear'))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(10),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:10, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")
result$history$mse
train_x
train_y
dat_preproc <- recipe(TheifperPop~., data= dat) %>%
step_naomit() %>%
step_normalize(all_numeric_predictors()) %>%
step_select(-X) %>%
prep(NULL) %>%
juice()
glimpse(dat_preproc, 60)
## data spliting
split <- initial_split(dat_preproc, prop = 0.8)
train <- training(split)
test <- testing(split)
train_x <- train %>% select(-TheifperPop) %>% as.matrix()
train_y <- train %>% select(TheifperPop) %>% as.matrix()
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 10, activation = 'linear'))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(10),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:10, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")
result$history$mse
train_x
result
result$model
write.csv(train, file="train.csv")
write.csv(test, file="test.csv")
reticulate::repl_python()
library(tidymodels)
ncol(train_x)
reticulate::repl_python()
dat <- read.csv("criminal.csv")
head(dat[,-1])
head(dat[,-1])
glimpse(dat[,-1], 60)
library(tidymodels)
dat_preproc <- recipe(TheifperPop~., data= dat) %>%
step_naomit() %>%
step_normalize(all_numeric_predictors()) %>%
step_select(-X) %>%
prep(NULL) %>%
juice()
glimpse(dat_preproc, 60)
dat <- dat %>% drop_na()
summary(dat)
dat_preproc <- recipe(TheifperPop~., data= dat) %>%
step_normalize(all_numeric_predictors()) %>%
step_select(-X) %>%
prep(NULL) %>%
juice()
glimpse(dat_preproc, 60)
## data spliting
split <- initial_split(dat_preproc, prop = 0.8)
train <- training(split)
test <- testing(split)
train_x <- train %>% select(-TheifperPop) %>% as.matrix()
train_y <- train %>% select(TheifperPop) %>% as.matrix()
write.csv(train, file="train.csv")
write.csv(test, file="test.csv")
reticulate::repl_python()
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 10, activation = 'linear'))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(10),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:10, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")
result$history$mse
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:10, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")
result$history$mse
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")
result$history$mse
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
scale_y_log10()
result$history$mse
test_x <- test %>% select(-TheifperPop) %>% as.matrix()
test_y <- test %>% select(TheifperPop) %>% as.matrix()
result$model$evaluate(x = test_x, y = test_y)
mse <- result$model$evaluate(x = test_x, y = test_y)
mse
mse[1]
mse[1] %>% sqrt()
mse[1]
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = result$history$val_mse) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
scale_y_log10()
result$history$mse
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result$history$mse
result$history$mse
result$history$val_mse
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result$history$mse
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result$history$mse
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 1, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result$history$mse
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 5, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.1, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.6, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 10, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.6, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(100),
validation_split = 0.5, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 32, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 16, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.5, verbose=F)
data.frame(epoch = 1:100, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")+
scale_y_log10()
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,600)+
ylab("RMSE")+
scale_y_log10()
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,700)+
ylab("RMSE")+
scale_y_log10()
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,700)+
ylab("RMSE")
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,600)+
ylab("RMSE")
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 32, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 16, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'relu'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,600)+
ylab("RMSE")
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 32, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 16, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,600)+
ylab("RMSE")
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,600)+
ylab("RMSE")
result$history$mse
result$history$val_mse
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylim(0,600)+
ylab("RMSE")
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")
mean(c(16,1))
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'linear', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'linear'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 10, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'relu'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 8, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'relu'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result <- model$fit(x = train_x, y =train_y,
epochs=as.integer(500),
validation_split = 0.3, verbose=F)
data.frame(epoch = 1:500, rmse_train = sqrt(result$history$mse),
rmse_validate = sqrt(result$history$val_mse)) %>%
ggplot(aes(x=epoch))+
geom_line(aes(y=rmse_train), col="steelblue")+
geom_line(aes(y=rmse_validate), col="orange")+
ylab("RMSE")
pred_test <- model$predict(test_x)
plot(test_y, pred_test)
pred_test <- model$predict(test_x)
plot(test_y, pred_test)
cor(test_y, pred_test)
install.packages("kerasTuner")
install.packages("kerastuneR")
library(kerastuneR)
library(kerastuneR)
tune <- import("keras-tuner")
tune <- import("Kerastuner")
tune <- import("keras-tuner")
install.packages("keras")
library(kears)
library(keras)
library(reticulate)
keras <- import("keras")
# create sequential model
model <- keras$Sequential()
# add layers
model$add(keras$layers$Dense(units = 8, activation = 'relu', input_dim = ncol(train_x)))
model$add(keras$layers$Dense(units = 1, activation = 'relu'))
# Compile the model
model$compile(loss = 'mse', optimizer = 'adam', metrics = 'mse')
model$summary()
result$history$loss
result$history$mse
sqrt(255819.6)
pred_test
reticulate::repl_python()
library(reticulate)
keras <- import("keras")
keras_tune <- import("kerastuner")
reticulate::repl_python()
